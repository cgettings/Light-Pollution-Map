{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./inst/htmlwidgets/bindings/lfx-draw-bindings.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","LeafletWidget","methods","addDrawToolbar","targetLayerId","targetGroup","options","editableFeatureGroup","map","this","drawToolbar","removeFrom","drawToobar","layerManager","getLayer","_editableGeoJSONLayerId","getLayerGroup","_editableFeatureGroupName","draw","marker","markerIcon","markerIconFunction","icon","$","isEmptyObject","edit","editOptions","remove","selectedPathOptions","poly","featureGroup","L","Control","Draw","addTo","on","Event","DRAWSTART","e","HTMLWidgets","shinyMode","Shiny","onInputChange","id","feature_type","layerType","DRAWSTOP","CREATED","singleFeature","getLayers","length","clearLayers","layer","addLayer","featureId","stamp","feature","type","properties","_leaflet_id","getRadius","radius","toGeoJSON","EDITSTART","EDITSTOP","EDITED","layers","eachLayer","layerId","DELETESTART","DELETESTOP","DELETED","removeDrawToolbar","clearFeatures","removeLayer","getDrawnItems"],"mappings":"aACA,IAAAA,KAGA,SAAAC,EAAAC,GAGA,GAAAF,EAAAE,GACA,OAAAF,EAAAE,GAAAC,QAGA,IAAAC,EAAAJ,EAAAE,IACAG,EAAAH,EACAI,GAAA,EACAH,YAUA,OANAI,EAAAL,GAAAM,KAAAJ,EAAAD,QAAAC,IAAAD,QAAAF,GAGAG,EAAAE,GAAA,EAGAF,EAAAD,QAKAF,EAAAQ,EAAAF,EAGAN,EAAAS,EAAAV,EAGAC,EAAAU,EAAA,SAAAR,EAAAS,EAAAC,GACAZ,EAAAa,EAAAX,EAAAS,IACAG,OAAAC,eAAAb,EAAAS,GACAK,cAAA,EACAC,YAAA,EACAC,IAAAN,KAMAZ,EAAAmB,EAAA,SAAAjB,GACAY,OAAAC,eAAAb,EAAA,cAAiDkB,OAAA,KAIjDpB,EAAAqB,EAAA,SAAAlB,GACA,IAAAS,EAAAT,KAAAmB,WACA,WAA2B,OAAAnB,EAAA,SAC3B,WAAiC,OAAAA,GAEjC,OADAH,EAAAU,EAAAE,EAAA,IAAAA,GACAA,GAIAZ,EAAAa,EAAA,SAAAU,EAAAC,GAAsD,OAAAV,OAAAW,UAAAC,eAAAnB,KAAAgB,EAAAC,IAGtDxB,EAAA2B,EAAA,GAIA3B,IAAA4B,EAAA,mBCjEAC,cAAAC,QAAAC,eAAA,SAAAC,EAAAC,EAAAC,IACA,WAEA,IAWAC,EAXAC,EAAAC,KAaA,GAXAD,EAAAE,cACAF,EAAAE,YAAAC,WAAAH,UACAA,EAAAI,YASAR,EAAA,CAGA,KADAG,EAAAC,EAAAK,aAAAC,SAAA,UAAAV,IAKA,8BAAAA,EAAA,aAHAI,EAAAO,wBAAAX,OASAC,IACAA,EAAA,wBAEAE,EAAAC,EAAAK,aAAAG,cAAAX,GAAA,GACAG,EAAAS,0BAAAZ,EAcA,GAVAC,KAAAY,MAAAZ,EAAAY,KAAAC,QACAb,EAAAY,KAAAC,OAAAC,YACAd,EAAAY,KAAAC,OAAAE,qBACAf,EAAAY,KAAAC,OAAAG,KACAhB,EAAAY,KAAAC,OAAAE,mBACAf,EAAAY,KAAAC,OAAAC,cAKAG,EAAAC,cAAAlB,EAAAmB,MAAA,CACA,IAAAC,KACApB,EAAAmB,KAAAE,SACAD,EAAAC,QAAA,GAEArB,EAAAmB,UAEOF,EAAAC,cAAAlB,EAAAmB,KAAAG,uBACPF,EAAAD,QACAC,EAAAD,KAAAG,oBACAtB,EAAAmB,KAAAG,qBAJAF,EAAAD,MAAA,EAOAF,EAAAC,cAAAlB,EAAAmB,KAAAI,QACAH,EAAAG,KAAAvB,EAAAmB,KAAAI,MAGAH,EAAAI,aAAAvB,EACAD,EAAAmB,KAAAC,EAGAlB,EAAAE,YAAA,IAAAqB,EAAAC,QAAAC,KAAA3B,GACAE,EAAAE,YAAAwB,MAAA1B,GAGAA,EAAA2B,GAAAJ,EAAAE,KAAAG,MAAAC,UAAA,SAAAC,GACAC,YAAAC,WACAC,MAAAC,cAAAlC,EAAAmC,GAAA,eAAiDC,aAAAN,EAAAO,cAGjDrC,EAAA2B,GAAAJ,EAAAE,KAAAG,MAAAU,SAAA,SAAAR,GACAC,YAAAC,WACAC,MAAAC,cAAAlC,EAAAmC,GAAA,cAAgDC,aAAAN,EAAAO,cAGhDrC,EAAA2B,GAAAJ,EAAAE,KAAAG,MAAAW,QAAA,SAAAT,GACAhC,EAAAY,KAAA8B,eACAzC,EAAA0C,YAAAC,OAAA,GACA3C,EAAA4C,cAIA,IAAAC,EAAAd,EAAAc,MACA7C,EAAA8C,SAAAD,GAGA,IAAAE,EAAAvB,EAAAwB,MAAAH,GACAA,EAAAI,SACAC,KAAA,UACAC,YACAC,YAAAL,EACAV,aAAAN,EAAAO,YAMA,mBAAAO,EAAAQ,YACAR,EAAAI,QAAAE,WAAAG,OAAAT,EAAAQ,aAGArB,YAAAC,YAEAC,MAAAC,cAAAlC,EAAAmC,GAAA,oBACAS,EAAAU,aACArB,MAAAC,cAAAlC,EAAAmC,GAAA,qBACApC,EAAAuD,gBAGAtD,EAAA2B,GAAAJ,EAAAE,KAAAG,MAAA2B,UAAA,SAAAzB,GACAC,YAAAC,WACAC,MAAAC,cAAAlC,EAAAmC,GAAA,wBAEAnC,EAAA2B,GAAAJ,EAAAE,KAAAG,MAAA4B,SAAA,SAAA1B,GACAC,YAAAC,WACAC,MAAAC,cAAAlC,EAAAmC,GAAA,uBAGAnC,EAAA2B,GAAAJ,EAAAE,KAAAG,MAAA6B,OAAA,SAAA3B,GACA,IAAA4B,EAAA5B,EAAA4B,OACAA,EAAAC,UAAA,SAAAf,GACA,IAAAE,EAAAvB,EAAAwB,MAAAH,GACAA,EAAAI,UACAJ,EAAAI,SAA2BC,KAAA,YAE3BL,EAAAI,QAAAE,aACAN,EAAAI,QAAAE,eAEAN,EAAAI,QAAAE,WAAAC,YAAAL,EACAF,EAAAI,QAAAE,WAAAU,QAAAhB,EAAA9C,QAAA8D,QACA,mBAAAhB,EAAAQ,YACAR,EAAAI,QAAAE,WAAAG,OAAAT,EAAAQ,eAIArB,YAAAC,YAEAC,MAAAC,cAAAlC,EAAAmC,GAAA,wBACAuB,EAAAJ,aACArB,MAAAC,cAAAlC,EAAAmC,GAAA,qBACApC,EAAAuD,gBAGAtD,EAAA2B,GAAAJ,EAAAE,KAAAG,MAAAiC,YAAA,SAAA/B,GACAC,YAAAC,WACAC,MAAAC,cAAAlC,EAAAmC,GAAA,0BAGAnC,EAAA2B,GAAAJ,EAAAE,KAAAG,MAAAkC,WAAA,SAAAhC,GACAC,YAAAC,WACAC,MAAAC,cAAAlC,EAAAmC,GAAA,yBAGAnC,EAAA2B,GAAAJ,EAAAE,KAAAG,MAAAmC,QAAA,SAAAjC,GACA,IAAA4B,EAAA5B,EAAA4B,OACAA,EAAAC,UAAA,SAAAf,GACA,IAAAE,EAAAvB,EAAAwB,MAAAH,GACAA,EAAAI,UACAJ,EAAAI,SAA2BC,KAAA,YAE3BL,EAAAI,QAAAE,aACAN,EAAAI,QAAAE,eAEAN,EAAAI,QAAAE,WAAAC,YAAAL,EACAF,EAAAI,QAAAE,WAAAU,QAAAhB,EAAA9C,QAAA8D,QACA,mBAAAhB,EAAAQ,YACAR,EAAAI,QAAAE,WAAAG,OAAAT,EAAAQ,eAIArB,YAAAC,YACAC,MAAAC,cAAAlC,EAAAmC,GAAA,yBACAuB,EAAAJ,aACArB,MAAAC,cAAAlC,EAAAmC,GAAA,qBACApC,EAAAuD,kBAGGnF,KAAA8B,OAIHR,cAAAC,QAAAsE,kBAAA,SAAAC,IACA,WAEA,IAAAjE,EAAAC,MAEAD,EAAAE,cACAF,EAAAE,YAAAC,WAAAH,UACAA,EAAAE,aAEAF,EAAAS,2BAAAwD,IACAjE,EAAAK,aAAAG,cAAAR,EAAAS,2BAAA,GACAkC,cAEA3C,EAAAS,0BAAA,KACAT,EAAAO,yBAAA0D,GACAjE,EAAAK,aAAA6D,YAAA,UAAAlE,EAAAO,yBAEAP,EAAAO,wBAAA,OACGpC,KAAA8B,OAIHR,cAAAC,QAAAyE,cAAA,WACA,IAEA7C,EAMA,OARArB,KAGAM,wBACAe,EAJArB,KAIAI,aAAAC,SAAA,UAJAL,KAIAM,yBAJAN,KAKGQ,4BACHa,EANArB,KAMAI,aAAAG,cANAP,KAMAQ,2BAAA,IAEAa,EACAA,EAAAgC,YAEA","file":"lfx-draw-bindings.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/* global LeafletWidget, $, L, Shiny, HTMLWidgets */\n\nLeafletWidget.methods.addDrawToolbar = function(targetLayerId, targetGroup, options) {\n  (function(){\n\n    var map = this;\n\n    if(map.drawToolbar) {\n      map.drawToolbar.removeFrom(map);\n      delete map.drawToobar;\n    }\n\n    // FeatureGroup that will hold our drawn shapes/markers\n    // This can be an existing GeoJSON layer whose features can be edited/deleted or new ones added.\n    // OR an existing FeatureGroup whose features can be edited/deleted or new ones added.\n    // OR a new FeatureGroup to hold drawn shapes.\n    var editableFeatureGroup;\n\n    if(targetLayerId) {\n      // If we're given an existing GeoJSON layer find it and use it\n      editableFeatureGroup = map.layerManager.getLayer('geojson', targetLayerId);\n      if(editableFeatureGroup) {\n        map._editableGeoJSONLayerId = targetLayerId;\n      } else {\n        // throw an error if we can't find the target GeoJSON layer\n        throw 'GeoJSON layer with ID '+targetLayerId+' not Found';\n      }\n    } else {\n      // If we're given an existing FeatureLayer use that.\n      // In this case we don't throw an error if the specified FeatureGroup is not found,\n      // we silently create a new one.\n      if(!targetGroup) {\n        targetGroup = 'editableFeatureGroup';\n      }\n      editableFeatureGroup = map.layerManager.getLayerGroup(targetGroup, true);\n      map._editableFeatureGroupName = targetGroup;\n    }\n\n    // Create appropriate Marker Icon.\n    if(options && options.draw && options.draw.marker) {\n      if(options.draw.marker.markerIcon &&\n        options.draw.marker.markerIconFunction) {\n        options.draw.marker.icon =\n          options.draw.marker.markerIconFunction(\n            options.draw.marker.markerIcon);\n      }\n    }\n\n    // create appropriate options\n    if(!$.isEmptyObject(options.edit)) {\n      var editOptions = {};\n      if(!options.edit.remove) {\n        editOptions.remove = false;\n      }\n      if(!options.edit.edit) {\n        editOptions.edit = false;\n      } else if(!$.isEmptyObject(options.edit.selectedPathOptions)) {\n        editOptions.edit = {};\n        editOptions.edit.selectedPathOptions =\n          options.edit.selectedPathOptions;\n      }\n\n      if(!$.isEmptyObject(options.edit.poly)) {\n        editOptions.poly = options.edit.poly;\n      }\n\n      editOptions.featureGroup = editableFeatureGroup;\n      options.edit = editOptions;\n    }\n\n    map.drawToolbar =  new L.Control.Draw(options);\n    map.drawToolbar.addTo(map);\n\n    // Event Listeners\n    map.on(L.Draw.Event.DRAWSTART, function(e) {\n      if (!HTMLWidgets.shinyMode) return;\n      Shiny.onInputChange(map.id+'_draw_start', {'feature_type': e.layerType});\n    });\n\n    map.on(L.Draw.Event.DRAWSTOP, function(e) {\n      if (!HTMLWidgets.shinyMode) return;\n      Shiny.onInputChange(map.id+'_draw_stop', {'feature_type': e.layerType});\n    });\n\n    map.on(L.Draw.Event.CREATED, function (e) {\n      if (options.draw.singleFeature){\n        if (editableFeatureGroup.getLayers().length > 0) {\n          editableFeatureGroup.clearLayers();\n        }\n      }\n\n      var layer = e.layer;\n      editableFeatureGroup.addLayer(layer);\n\n      // assign a unique key to the newly created feature\n      var featureId = L.stamp(layer);\n      layer.feature = {\n        'type' : 'Feature',\n        'properties' : {\n          '_leaflet_id' : featureId,\n          'feature_type' : e.layerType\n        }\n      };\n\n      // circles are just Points and toGeoJSON won't store radius by default\n      // so we store it inside the properties.\n      if(typeof layer.getRadius === 'function') {\n        layer.feature.properties.radius = layer.getRadius();\n      }\n\n      if (!HTMLWidgets.shinyMode) return;\n\n      Shiny.onInputChange(map.id+'_draw_new_feature',\n        layer.toGeoJSON());\n      Shiny.onInputChange(map.id+'_draw_all_features',\n        editableFeatureGroup.toGeoJSON());\n    });\n\n    map.on(L.Draw.Event.EDITSTART, function (e) {\n      if (!HTMLWidgets.shinyMode) return;\n      Shiny.onInputChange(map.id+'_draw_editstart', true);\n    });\n    map.on(L.Draw.Event.EDITSTOP, function (e) {\n      if (!HTMLWidgets.shinyMode) return;\n      Shiny.onInputChange(map.id+'_draw_editstop', true);\n    });\n\n    map.on(L.Draw.Event.EDITED, function (e) {\n      var layers = e.layers;\n      layers.eachLayer(function(layer){\n        var featureId = L.stamp(layer);\n        if(!layer.feature) {\n          layer.feature = {'type' : 'Feature'};\n        }\n        if(!layer.feature.properties) {\n          layer.feature.properties = {};\n        }\n        layer.feature.properties._leaflet_id = featureId;\n        layer.feature.properties.layerId = layer.options.layerId;\n        if(typeof layer.getRadius === 'function') {\n          layer.feature.properties.radius = layer.getRadius();\n        }\n      });\n\n      if (!HTMLWidgets.shinyMode) return;\n\n      Shiny.onInputChange(map.id+'_draw_edited_features',\n        layers.toGeoJSON());\n      Shiny.onInputChange(map.id+'_draw_all_features',\n        editableFeatureGroup.toGeoJSON());\n    });\n\n    map.on(L.Draw.Event.DELETESTART, function (e) {\n      if (!HTMLWidgets.shinyMode) return;\n      Shiny.onInputChange(map.id+'_draw_deletestart', true);\n    });\n\n    map.on(L.Draw.Event.DELETESTOP, function (e) {\n      if (!HTMLWidgets.shinyMode) return;\n      Shiny.onInputChange(map.id+'_draw_deletestop', true);\n    });\n\n    map.on(L.Draw.Event.DELETED, function (e) {\n      var layers = e.layers;\n      layers.eachLayer(function(layer){\n        var featureId = L.stamp(layer);\n        if(!layer.feature) {\n          layer.feature = {'type' : 'Feature'};\n        }\n        if(!layer.feature.properties) {\n          layer.feature.properties = {};\n        }\n        layer.feature.properties._leaflet_id = featureId;\n        layer.feature.properties.layerId = layer.options.layerId;\n        if(typeof layer.getRadius === 'function') {\n          layer.feature.properties.radius = layer.getRadius();\n        }\n      });\n\n      if (!HTMLWidgets.shinyMode) return;\n      Shiny.onInputChange(map.id+'_draw_deleted_features',\n        layers.toGeoJSON());\n      Shiny.onInputChange(map.id+'_draw_all_features',\n        editableFeatureGroup.toGeoJSON());\n    });\n\n  }).call(this);\n\n};\n\nLeafletWidget.methods.removeDrawToolbar = function(clearFeatures) {\n  (function(){\n\n    var map = this;\n\n    if(map.drawToolbar) {\n      map.drawToolbar.removeFrom(map);\n      delete map.drawToolbar;\n    }\n    if(map._editableFeatureGroupName && clearFeatures) {\n      var featureGroup = map.layerManager.getLayerGroup(map._editableFeatureGroupName, false);\n      featureGroup.clearLayers();\n    }\n    map._editableFeatureGroupName = null;\n    if(map._editableGeoJSONLayerId && clearFeatures) {\n      map.layerManager.removeLayer('geojson', map._editableGeoJSONLayerId);\n    }\n    map._editableGeoJSONLayerId = null;\n  }).call(this);\n\n};\n\nLeafletWidget.methods.getDrawnItems = function() {\n  var map = this;\n\n  var featureGroup;\n  if(map._editableGeoJSONLayerId) {\n    featureGroup = map.layerManager.getLayer('geojson', map._editableGeoJSONLayerId);\n  } else if(map._editableFeatureGroupName) {\n    featureGroup = map.layerManager.getLayerGroup(map._editableFeatureGroupName, false);\n  }\n  if(featureGroup) {\n    return featureGroup.toGeoJSON();\n  } else {\n    return null;\n  }\n\n};\n"],"sourceRoot":""}