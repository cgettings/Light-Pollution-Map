{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/leaflet.tilelayer.pouchdbcached/L.TileLayer.PouchDBCached.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","L","TileLayer","addInitHook","this","options","useCache","_db","_canvas","dbOptions","PouchDB","document","createElement","getContext","saveToCache","useOnlyCache","cacheFormat","cacheMaxAge","include","createTile","coords","done","tile","onerror","bind","_tileOnError","crossOrigin","alt","tileUrl","getTileUrl","revs_info","_onCacheLookup","onload","_tileOnLoad","src","err","data","fire","url","Date","now","timestamp","_saveTile","_revs_info","rev","ev","dataUrl","Util","falseFn","emptyImageUrl","existingRevision","width","naturalWidth","height","naturalHeight","drawImage","toDataURL","error","doc","_id","then","put","_rev","response","seed","bbox","minZoom","maxZoom","_map","queue","z","northEastPoint","project","getNorthEast","southWestPoint","getSouthWest","tileSize","getTileSize","tileBounds","bounds","point","Math","floor","x","y","j","min","max","Point","push","_getTileUrl","seedData","queueLength","length","_createTile","_layer","_seedOneTile","Image","zoom","zoomReverse","zoomOffset","template","_url","extend","detectRetina","Browser","retina","_getSubdomain","tms","_globalTileRange","maxNativeZoom","remaining","remainingLength","pop","e"],"mappings":"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","file":"lfx-tilelayer-prod.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","\n\nL.TileLayer.addInitHook(function() {\n\n\tif (!this.options.useCache) {\n\t\tthis._db     = null;\n\t\tthis._canvas = null;\n\t\treturn;\n\t}\n\n\tif (this.options.dbOptions) {\n\t\tthis._db = new PouchDB('offline-tiles', this.options.dbOptions);\n\t} else {\n\t\tthis._db = new PouchDB('offline-tiles');\n\t}\n\tthis._canvas = document.createElement('canvas');\n\n\tif (!(this._canvas.getContext && this._canvas.getContext('2d'))) {\n\t\t// HTML5 canvas is needed to pack the tiles as base64 data. If\n\t\t//   the browser doesn't support canvas, the code will forcefully\n\t\t//   skip caching the tiles.\n\t\tthis._canvas = null;\n\t}\n});\n\n// üçÇnamespace TileLayer\n// üçÇsection PouchDB tile caching options\n// üçÇoption useCache: Boolean = false\n// Whether to use a PouchDB cache on this tile layer, or not\nL.TileLayer.prototype.options.useCache     = false;\n\n// üçÇoption saveToCache: Boolean = true\n// When caching is enabled, whether to save new tiles to the cache or not\nL.TileLayer.prototype.options.saveToCache  = true;\n\n// üçÇoption useOnlyCache: Boolean = false\n// When caching is enabled, whether to request new tiles from the network or not\nL.TileLayer.prototype.options.useOnlyCache = false;\n\n// üçÇoption useCache: String = 'image/png'\n// The image format to be used when saving the tile images in the cache\nL.TileLayer.prototype.options.cacheFormat = 'image/png';\n\n// üçÇoption cacheMaxAge: Number = 24*3600*1000\n// Maximum age of the cache, in milliseconds\nL.TileLayer.prototype.options.cacheMaxAge  = 24*3600*1000;\n\n\nL.TileLayer.include({\n\n\t// Overwrites L.TileLayer.prototype.createTile\n\tcreateTile: function(coords, done) {\n\t\tvar tile = document.createElement('img');\n\n\t\ttile.onerror = L.bind(this._tileOnError, this, done, tile);\n\n\t\tif (this.options.crossOrigin) {\n\t\t\ttile.crossOrigin = '';\n\t\t}\n\n\t\t/*\n\t\t Alt tag is *set to empty string to keep screen readers from reading URL and for compliance reasons\n\t\t http://www.w3.org/TR/WCAG20-TECHS/H67\n\t\t */\n\t\ttile.alt = '';\n\n\t\tvar tileUrl = this.getTileUrl(coords);\n\n\t\tif (this.options.useCache && this._canvas) {\n\t\t\tthis._db.get(tileUrl, {revs_info: true}, this._onCacheLookup(tile, tileUrl, done));\n\t\t} else {\n\t\t\t// Fall back to standard behaviour\n\t\t\ttile.onload = L.bind(this._tileOnLoad, this, done, tile);\n\t\t}\n\n\t\ttile.src = tileUrl;\n\t\treturn tile;\n\t},\n\n\t// Returns a callback (closure over tile/key/originalSrc) to be run when the DB\n\t//   backend is finished with a fetch operation.\n\t_onCacheLookup: function(tile, tileUrl, done) {\n\t\treturn function(err, data) {\n\t\t\tif (data) {\n\t\t\t\tthis.fire('tilecachehit', {\n\t\t\t\t\ttile: tile,\n\t\t\t\t\turl: tileUrl\n\t\t\t\t});\n\t\t\t\tif (Date.now() > data.timestamp + this.options.cacheMaxAge && !this.options.useOnlyCache) {\n\t\t\t\t\t// Tile is too old, try to refresh it\n\t\t\t\t\t//console.log('Tile is too old: ', tileUrl);\n\n\t\t\t\t\tif (this.options.saveToCache) {\n\t\t\t\t\t\ttile.onload = L.bind(this._saveTile, this, tile, tileUrl, data._revs_info[0].rev, done);\n\t\t\t\t\t}\n\t\t\t\t\ttile.crossOrigin = 'Anonymous';\n\t\t\t\t\ttile.src = tileUrl;\n\t\t\t\t\ttile.onerror = function(ev) {\n\t\t\t\t\t\t// If the tile is too old but couldn't be fetched from the network,\n\t\t\t\t\t\t//   serve the one still in cache.\n\t\t\t\t\t\tthis.src = data.dataUrl;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Serve tile from cached data\n\t\t\t\t\t//console.log('Tile is cached: ', tileUrl);\n\t\t\t\t\ttile.onload = L.bind(this._tileOnLoad, this, done, tile);\n\t\t\t\t\ttile.src = data.dataUrl;    // data.dataUrl is already a base64-encoded PNG image.\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.fire('tilecachemiss', {\n\t\t\t\t\ttile: tile,\n\t\t\t\t\turl: tileUrl\n\t\t\t\t});\n\t\t\t\tif (this.options.useOnlyCache) {\n\t\t\t\t\t// Offline, not cached\n// \t\t\t\t\tconsole.log('Tile not in cache', tileUrl);\n\t\t\t\t\ttile.onload = L.Util.falseFn;\n\t\t\t\t\ttile.src = L.Util.emptyImageUrl;\n\t\t\t\t} else {\n\t\t\t\t\t//Online, not cached, request the tile normally\n// \t\t\t\t\tconsole.log('Requesting tile normally', tileUrl);\n\t\t\t\t\tif (this.options.saveToCache) {\n\t\t\t\t\t\ttile.onload = L.bind(this._saveTile, this, tile, tileUrl, null, done);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttile.onload = L.bind(this._tileOnLoad, this, done, tile);\n\t\t\t\t\t}\n\t\t\t\t\ttile.crossOrigin = 'Anonymous';\n\t\t\t\t\ttile.src = tileUrl;\n\t\t\t\t}\n\t\t\t}\n\t\t}.bind(this);\n\t},\n\n\t// Returns an event handler (closure over DB key), which runs\n\t//   when the tile (which is an <img>) is ready.\n\t// The handler will delete the document from pouchDB if an existing revision is passed.\n\t//   This will keep just the latest valid copy of the image in the cache.\n\t_saveTile: function(tile, tileUrl, existingRevision, done) {\n\t\tif (this._canvas === null) return;\n\t\tthis._canvas.width  = tile.naturalWidth  || tile.width;\n\t\tthis._canvas.height = tile.naturalHeight || tile.height;\n\n\t\tvar context = this._canvas.getContext('2d');\n\t\tcontext.drawImage(tile, 0, 0);\n\n\t\tvar dataUrl;\n\t\ttry {\n\t\t\tdataUrl = this._canvas.toDataURL(this.options.cacheFormat);\n\t\t} catch(err) {\n\t\t\tthis.fire('tilecacheerror', { tile: tile, error: err });\n\t\t\treturn done();\n\t\t}\n\n\t\tvar doc = {_id: tileUrl, dataUrl: dataUrl, timestamp: Date.now()};\n\t    if (existingRevision) {\n\t      this._db.get(tileUrl).then(function(doc) {\n\t          return this._db.put({\n\t              _id: doc._id,\n\t              _rev: doc._rev,\n\t              dataUrl: dataUrl,\n\t              timestamp: Date.now()\n\t          });\n\t      }.bind(this)).then(function(response) {\n\t        //console.log('_saveTile update: ', response);\n\t      });\n\t    } else {\n\t      this._db.put(doc).then( function(doc) {\n\t        //console.log('_saveTile insert: ', doc);\n\t      });\n\t    }\n\n\t    if (done) {\n\t      done();\n\t    }\n\t},\n\n\t// üçÇsection PouchDB tile caching options\n\t// üçÇmethod seed(bbox: LatLngBounds, minZoom: Number, maxZoom: Number): this\n\t// Starts seeding the cache given a bounding box and the minimum/maximum zoom levels\n\t// Use with care! This can spawn thousands of requests and flood tileservers!\n\tseed: function(bbox, minZoom, maxZoom) {\n\t\tif (!this.options.useCache) return;\n\t\tif (minZoom > maxZoom) return;\n\t\tif (!this._map) return;\n\n\t\tvar queue = [];\n\n\t\tfor (var z = minZoom; z<=maxZoom; z++) {\n\n\t\t\tvar northEastPoint = this._map.project(bbox.getNorthEast(),z);\n\t\t\tvar southWestPoint = this._map.project(bbox.getSouthWest(),z);\n\n\t\t\t// Calculate tile indexes as per L.TileLayer._update and\n\t\t\t//   L.TileLayer._addTilesFromCenterOut\n\t\t\tvar tileSize = this.getTileSize();\n\t\t\tvar tileBounds = L.bounds(\n\t\t\t\tL.point(Math.floor(northEastPoint.x / tileSize.x), Math.floor(northEastPoint.y / tileSize.y)),\n\t\t\t\tL.point(Math.floor(southWestPoint.x / tileSize.x), Math.floor(southWestPoint.y / tileSize.y)));\n\n\t\t\tfor (var j = tileBounds.min.y; j <= tileBounds.max.y; j++) {\n\t\t\t\tfor (var i = tileBounds.min.x; i <= tileBounds.max.x; i++) {\n\t\t\t\t\tpoint = new L.Point(i, j);\n\t\t\t\t\tpoint.z = z;\n\t\t\t\t\tqueue.push(this._getTileUrl(point));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar seedData = {\n\t\t\tbbox: bbox,\n\t\t\tminZoom: minZoom,\n\t\t\tmaxZoom: maxZoom,\n\t\t\tqueueLength: queue.length\n\t\t}\n\t\tthis.fire('seedstart', seedData);\n\t\tvar tile = this._createTile();\n\t\ttile._layer = this;\n\t\tthis._seedOneTile(tile, queue, seedData);\n\t\treturn this;\n\t},\n\n\t_createTile: function () {\n\t\treturn new Image();\n\t},\n\n\t// Modified L.TileLayer.getTileUrl, this will use the zoom given by the parameter coords\n\t//  instead of the maps current zoomlevel.\n\t_getTileUrl: function (coords) {\n\t\tvar zoom = coords.z;\n\t\tif (this.options.zoomReverse) {\n\t\t\tzoom = this.options.maxZoom - zoom;\n\t\t}\n\t\tzoom += this.options.zoomOffset;\n\t\treturn L.Util.template(this._url, L.extend({\n\t\t\tr: this.options.detectRetina && L.Browser.retina && this.options.maxZoom > 0 ? '@2x' : '',\n\t\t\ts: this._getSubdomain(coords),\n\t\t\tx: coords.x,\n\t\t\ty: this.options.tms ? this._globalTileRange.max.y - coords.y : coords.y,\n\t\t\tz: this.options.maxNativeZoom ? Math.min(zoom, this.options.maxNativeZoom) : zoom\n\t\t}, this.options));\n\t},\n\n\t// Uses a defined tile to eat through one item in the queue and\n\t//   asynchronously recursively call itself when the tile has\n\t//   finished loading.\n\t_seedOneTile: function(tile, remaining, seedData) {\n\t\tif (!remaining.length) {\n\t\t\tthis.fire('seedend', seedData);\n\t\t\treturn;\n\t\t}\n\t\tthis.fire('seedprogress', {\n\t\t\tbbox:    seedData.bbox,\n\t\t\tminZoom: seedData.minZoom,\n\t\t\tmaxZoom: seedData.maxZoom,\n\t\t\tqueueLength: seedData.queueLength,\n\t\t\tremainingLength: remaining.length\n\t\t});\n\n\t\tvar url = remaining.pop();\n\n\t\tthis._db.get(url, function(err, data) {\n\t\t\tif (!data) {\n\t\t\t\ttile.onload = function(e) {\n\t\t\t\t\tthis._saveTile(tile, url, null);\n\t\t\t\t\tthis._seedOneTile(tile, remaining, seedData);\n\t\t\t\t}.bind(this);\n\t\t\t\ttile.onerror = function(e) {\n\t\t\t\t\t// Could not load tile, let's continue anyways.\n\t\t\t\t\tthis._seedOneTile(tile, remaining, seedData);\n\t\t\t\t}.bind(this);\n\t\t\t\ttile.crossOrigin = 'Anonymous';\n\t\t\t\ttile.src = url;\n\t\t\t} else {\n\t\t\t\tthis._seedOneTile(tile, remaining, seedData);\n\t\t\t}\n\t\t}.bind(this));\n\t}\n\n});\n"],"sourceRoot":""}