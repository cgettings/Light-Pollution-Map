<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>COG</title>
    <link rel="stylesheet" href="/node_modules/leaflet/dist/leaflet.css"/>
    <style>
        #map {
            bottom: 0;
            left: 0;
            position: absolute;
            right: 0;
            top: 0;
        }
    </style>
    <link rel="stylesheet" href="/node_modules/@fortawesome/fontawesome-free/css/all.css"/>
</head>
<body>
    <div id="map"></div>

    <script src="/node_modules/d3/dist/d3.min.js"></script>
    <script src="/node_modules/chroma-js/chroma.min.js"></script>
    <script src="/node_modules/proj4/dist/proj4.js"></script>
    <script src="/node_modules/leaflet/dist/leaflet.js"></script>
    <script src="/node_modules/jquery/dist/jquery.min.js"></script>
    <script src="/node_modules/georaster/dist/georaster.browser.bundle.min.js"></script>
    <script src="/node_modules/georaster-layer-for-leaflet/dist/georaster-layer-for-leaflet.min.js"></script>
    <script src="/node_modules/geoblaze/dist/geoblaze.web.min.js"></script>
    <script src="leaflet-binding-2.1.1/leaflet.js"></script>
    
    <script src="SkyBrightness.js"></script>
    <script src="sky_brightness_breaks.js"></script>
    <script src="closest_dark_place.js"></script>

    <script>

        let gr;

        // let breaks;
        let min;
        let max;
        let diff;
        let domain;
        let scale;
        
        let sky_brightness_breaks = d3.json("sky_brightness_breaks.json")

        console.log("sky_brightness_breaks", sky_brightness_breaks);

        const range = (start, stop, step = 1) => Array.from({ length: (stop - start) / step + 1}, (_, i) => start + (i * step));
        // const range = (start, step, length) => Array.from({ length: length}, (_, i) => start + (i * step));


        let inferno = d3.scaleSequential(d3.interpolateInferno);

        let inferno_cols = range(0, 1, 1/64).map(c => inferno(1 - c))

        console.log("inferno_cols", inferno_cols);
        


        // initalize leaflet map
        let map = L.map('map');

        console.log("map", map);
        
        // add OpenStreetMap basemap
        L.tileLayer('http://{s}.tile.osm.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(map);
        
        let url_to_geotiff_file = "https://cgettings.github.io/Light-Pollution-Map/sky_brightness_COG.tif";
        
        parseGeoraster(url_to_geotiff_file).then(georaster => {
            
            console.log("georaster:", georaster);

            gr = georaster;

            let min_0 = [];
            let max_0 = [];

            let min_max = data['Sky Brightness'].map(x => {

                let no_null = x.filter(y => y !== null && Math.abs(y) !== Infinity);

                // let min_00 = Math.min.apply(null, no_null).filter(y => y !== null && Math.abs(y) !== Infinity);
                // let max_00 = Math.max.apply(null, no_null).filter(y => y !== null && Math.abs(y) !== Infinity);

                // let min_00 = Math.min.apply(null, no_null)
                // let max_00 = Math.max.apply(null, no_null)

                let min_00 = Math.min(...no_null)
                let max_00 = Math.max(...no_null)

                // console.log("min_00", min_00);
                // console.log("max_00", max_00);

                min_0.push(Math.min(...no_null));
                max_0.push(Math.max(...no_null));

                // return {min: min, max: max};

            })
            
            // console.log("min_max", min_max);

            min = Math.min(...min_0.filter(y => y !== null && Math.abs(y) !== Infinity));
            max = Math.min(...max_0.filter(y => y !== null && Math.abs(y) !== Infinity));

            // diff = max - min;
            
            console.log("min", min);
            console.log("max", max);
            // console.log("diff", diff);

            // console.log("range(min**16, max**16, diff/64)", range(min**16, max**16, diff**16/64));

            // breaks = range((min**16), ((diff**16)/64), 64).map(x => Math.sqrt(Math.sqrt(Math.sqrt(Math.sqrt(...x)))))
            // breaks = range((min**16), (max**16), (((max**16) - (min**16))/64)).map(x => Math.sqrt(Math.sqrt(Math.sqrt(Math.sqrt(x)))))

            console.log("breaks [1]", breaks);
            
            domain = [min, max]
            
            // get color palette etc
            scale = chroma.scale(inferno_cols);
            let nacol = "#00000000";
            
            // console.log("scale", scale);
            
            scale = scale.classes(breaks);
            
            // console.log("scale", scale);

            
            // define pixel value -> colorm mapping

            let pixelValuesToColorFn = values => {

                // console.log("values", values);

                let clr = scale.domain(domain);
                // console.log("clr", clr);

                if (isNaN(values) || values === georaster.noDataValue) return nacol;
                return clr(values).hex();
            };

            var layer = new GeoRasterLayer({
                attribution: "Unknown",
                georaster: georaster,
                pixelValuesToColorFn: pixelValuesToColorFn,
                resolution: 64,
                opacity: 0.7,
                mask: "./state_border.geojson",
                mask_strategy: "outside"
            });

            layer.addTo(map);
            
            map.fitBounds(layer.getBounds());
            
            map.on('click', function(evt) {

                var latlng = map.mouseEventToLatLng(evt.originalEvent);

                geoblaze
                    .identify(georaster, [latlng.lng, latlng.lat])
                    .then(id => console.log("click", id));

            });



            // map.on('mousemove', function(evt) {

            //     var latlng = map.mouseEventToLatLng(evt.originalEvent);

            //     geoblaze
            //         .identify(georaster, [latlng.lng, latlng.lat])
            //         .then(id => console.log("mousemove", id));

            // });
            
        });

        let grid_coords = [];

        fetch('sky_brightness_coords.json')
            .then(response => response.json())
            .then(async data => {

                // looping through all coords in data

                console.log("data:", data);

                for (var i = 0; i < data.x.length; i++) {
                    
                    grid_coords[i] = new L.LatLng(data.y[i], data.x[i], data.sky_brightness[i]);
                    
                }
                
            })
            .catch(error => console.log(error));
            
        console.log("grid_coords:", grid_coords);
        
    </script>
</body>
</html>